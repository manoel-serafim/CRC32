# CRC32
Because Error Correction is NOT colision resistant :D

Here I will give fairly optimized implementations of the CRC-32 FIPS PUB 71, CRC-32C, CRC-32K, CRC-32K2 and CRC-32Q [Aeronautical Information Exchange Model (AIXM)]

# Why should we detect & correct errors?

# How should we detect errors?
## Parity
By checking if our message is odd or even, we can see if an error has happened with only one bit. However, what if more than one error occures and generates a valid parity?


## Hamming Code
This is a clever trick to calculate the integrity of message sections and the integrity of their relation. It is actually quite simple, the main idea is that you will check the parity of blocks inside of the message and then the parity of the groups of blocks. However, we can only correct single-bit errors :/

[...]

## Checksums
To resolve that issue, we could sum our whole message and send this to another party. This way, we are starting to create a dependance between every bit of message with every bit of the checksum. However, what if 2+3 = 5 and an error occures that make my message = {4,1}? Then 4+1=5 and we cannot detect our error.

Even thou you can see this is not very good, lets actually understand how a checksum could be used:
### Detecting Errors with modulo divisions
We can convert a message made of bits into a DECIMAL number. By taking this number and performing a modulo operation with a specific code, we get a remainder. This remainder is used to check for the magic_number that makes the message number divisible by the code.

To ensure the message is error-free, we append this magic_number to the message. Later, to check if the message is correct, we simply verify whether the new number (message + magic_number) is divisible by the original code.

#### What is the code?
Choosing the specific code is crucial to what types of errors patternd we detect.

Remeber that to check if the data is error free, we verify that what we receive (Message+ magic_number) if divisible by this code. If the error generated is divisible by the code and added to the [message + magic_number], we are introducing an invisible error because the sum [message + error + magic_number] will be equal to a number that is divisible by the code :/

If we get a code that is equal to 1, because every possible error is algo divisible by 1, we would not be able to detect anything.

If we choose a code = 2, we are only checking the parity again. However, if all our messages where only one bit long, this would be "sufficient"

With a "big" number like the prime 65521, we get a bigger spectrum of possible errors, and so, we can check a bigger message.

To choose the code, you have to understand the type of error that is generated. However, we have a problem generated by the carry value of an error

### CRC relation with checksums
* CRC does not consider the message as a decimal number but actually as a polynomial.

* The code is another polynomial

* The rest is another polinomial

The main problem here is that whilst working with polinomials, we can get coefficients with a number that is different from 0 or 1. To solve this, lets use a tool that is also used in AES :D


# FINITE FIELDS 
Algebra is a set of rules that you can use to manipulate simbols to solve problems in a consistent manner.

The simbols we use to execute algebraic rules is a field.

A finite field is a field with a finite number of simbols that obey certain rules in order to be valid. 

# F[0,1] 
* (+) = XOR  
* (*) = AND

Choosing a generator poly
CRC-32 is a standard
Hamming distances, number of changes in a message and distance of 32 k



